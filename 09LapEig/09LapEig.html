<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>AMSI Winter  School 2021</title>
    <meta charset="utf-8" />
    <meta name="author" content="Anastasios Panagiotelis" />
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link rel="stylesheet" href="../css/mtheme.css" type="text/css" />
    <link rel="stylesheet" href="../css/mod.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# AMSI Winter </br> School 2021
## Dimension Reduction</br>Laplacian Eigenmaps
### Anastasios Panagiotelis
### University of Sydney

---

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
    Macros: {
      bA: "{\\mathbf{A}}",
      bC: "{\\mathbf{C}}",
      bv: "{\\mathbf{v}}",
      bw: "{\\mathbf{w}}",
      bx: "{\\mathbf{x}}",
      bX: "{\\mathbf{X}}",
      by: "{\\mathbf{y}}",
      bY: "{\\mathbf{Y}}",
      bw: "{\\mathbf{w}}",
      bW: "{\\mathbf{W}}",
      bz: "{\\mathbf{z}}",
      bU: "{\\mathbf{U}}",
      bS: "{\\mathbf{S}}",
      bff: "{\\mathbf{f}}",
      bD: "{\\mathbf{D}}",
      bL: "{\\mathbf{L}}",
      calL: "{\\mathcal{L}}",
      calM: "{\\mathcal{M}}",
      bbR: "{\\mathbb{R}}",
      bB: "{\\mathbf{B}}",
      bLambda: "{\\boldsymbol{\\Lambda}}",
      bDelta: "{\\boldsymbol{\\Delta}}",
      bH: "{\\mathbf{H}}",
      bI: "{\\mathbf{I}}",
      biota: "{\\boldsymbol{\\iota}}",
      bN: "{\\mathbf{N}}"
      }
  }
});
</script>

#Outline

- Laplace-Beltrami Operator
--

  + Heat Equation
--

- Graph Approximation
--

  + Algorithm
--

- Applications
--

- Reference is Belkin, M., &amp; Niyogi, P. (2001). "Laplacian eigenmaps and spectral techniques for embedding and clustering. ", *NeurIPS*, **14**.



---

class: center, middle, inverse

# Some Physics

---

# Motivation

- In manifold learning we find functions `\(f:\calM\rightarrow\bbR^d\)`
--

- For simplicity consider `\(d=1\)` (for now).
--

- As a useful analogy think of the output dimension as representing "heat".
--

- "Hot" points on the manifold should be close to other "hot" points and "cold" points should be close to other "cold" points.

---

# A simplification

- Suppose the manifold is just `\([0,1]\)`.
--

- The physical interpretation is an idealised 1-D rod.
--

- The function `\(f\)` indicates which part of the rod is hotter

---

# A plot

&lt;img src="09LapEig_files/figure-html/unnamed-chunk-1-1.png" height="450" style="display: block; margin: auto;" /&gt;

---

# Heat diffusion

- For a "good" function, how are the following quantities relevant?
--

  - The value of the first derivative.
  - The value of the second derivative.
--

- On average, first derivative should be small in magnitude.
--

- The value of the second derivative is connected to the idea of 'neighbourhood average'.


---

# Extension

- Consider `\(m\)`-dimensional Euclidean space as a manifold?
--

- In this case an infintesimal change in the function is given by
--

`$$df=\frac{\partial f}{\partial x_1}dx_1+\frac{\partial f}{\partial x_2}dx_2+\dots+\frac{\partial f}{\partial x_m}dx_m$$`
--

- Local averages related to Laplacian
--

`$$\frac{\partial^2 f}{\partial x^2_1}+\frac{\partial^2 f}{\partial x^2_2}+\dots+\frac{\partial^2 f}{\partial x^2_m}$$`
---

# Manifolds

- Suppose instead of Euclidean space we have a manifold
--

  + Imagine heat on a curved piece of metal
--

- Can still define analogues to
--

  + The gradient
  + The Laplacian
--

- Need to abstract from a specific coordinate system.

---

# Gradient 

The gradient of `\(f\)`, denoted `\(\nabla f\)` where `\(f:\calM\rightarrow\bbR\)` is a vector field such that
--

`$$df=&lt;\nabla f,d\bv&gt;$$`
where `\(&lt;,&gt;\)` is the Riemannian (an inner product on the tangent space) and `\(d\bv\)` is a tangent vector.

---

# Laplace Beltrami Operator 

- The Laplace Beltrami operator is defined as
--

`$$\Delta f=\nabla \cdot \nabla f$$`
--

- It is a linear operator (maps functions to functions).
--

- It is the Laplacian generalised for manifolds.
--

- The local average of points around `\(x\)` depends on the value of `\(\Delta f\)` at `\(x\)`

---

# Criterion

- Why is this relevant for manifold learning?
--

- The term `\(\int\limits_\calM ||\nabla f||^2\)` measures the average wiggliness of `\(f\)` on the manifold.
--

- If nearby points on the input space are mapped to nearby points nearby on the output space this will be small.

---

# Criterion

- By Stokes' theorem
`$$-\int\limits_\calM \Delta (f)f=\int\limits_\calM ||\nabla f||^2$$`
--

- There is a bit of hand-waving here but the idea is to use a generalisation of integration by parts (and the product rule) on manifolds.
--

- Laplacian Eigenmaps aims to minimise this criterion.


---

# Solution

- To solve this need to discretise the problem
--

  + Functions become vectors (function evalutated at each point of data)
  + Integrals become sums (over data points)
  + Operators become matrices
--

- Laplacian Eigenmaps uses a discrete approximation for the Laplace Beltrami operator

---

#Another Eigenvalue problem

- Let `\(\bff\)` is a `\(n\)`-vector of the function evaluated at each input point `\(\bff=\left(f(\bx_1),\dots,f(\bx_n)\right)\)`
--

- Let `\(\bD^{-1}\bL\)` is a `\(n\times n\)` matrix that approximates the Laplace Beltrami operator
--

- Discrete approximation
`$$-\int\limits_\calM \Delta (f)f\approx\bff'\bD^{-1}\bL\bff$$`
--

- Minimised by solving `\(\bD^{-1}\bL\bff=\lambda\bff\)`
---

class: inverse, middle, center

# Approximating the Laplace Beltrami Operator

---

# Roadmap

- How to find `\(\bD\bL\)`?
--

- Exploit connection between Laplace Beltrami operator and heat equation
--

- Do lots of algebra
--

- Do a few approximations along the way

---

# The heat equation

- Let `\(u(\bx_i,t)\)` be the heat at a point `\(\bx_i\in\calM\)` at time `\(t\)`. Also let `\(f\)` denote the initial heat distribution `\(f(\bx_i)=u(\bx_i,0)\)`.
--

- Heat diffusion is described by the following differential equation
--

`$$\Delta u = \frac{\partial}{\partial t}u$$`

---

# Fundamental solution

- An approximate solution is given by
--

`$$u(\bx_i,t)\approx(4\pi t)^{-\frac{d}{2}}\int\limits_{\calM}e^{\frac{||\bx_i-\bz||^2}{4t}}f(\bz)d\bz$$`
- Putting back into heat equation at `\(t=0\)` gives
--

`$$\Delta f(\bx_i)\approx\frac{\partial}{\partial t}\left[(4\pi t)^{-\frac{d}{2}}\int\limits_{\calM}e^{\frac{||\bx_i-\bz||^2}{4t}}f(\bz)d\bz\right]_{t=0}$$`
---

# Continuing

- By the definition of a derivative
--

`$$\Delta f(\bx_i)\approx\underset{t\rightarrow 0}{\lim}\frac{A(t)-A(0)}{t}$$`
--

- Where 
`$$A(t)=(4\pi t)^{-\frac{d}{2}}\int\limits_{\calM}e^{\frac{||\bx_i-\bz||^2}{4t}}f(\bz)d\bz$$`
--

- Note `\(A(0)=f(\bx_i)\)`

---

# And more

- Rearranging

`$$-\Delta f(\bx_i)\approx\underset{t\rightarrow 0}{\lim}\frac{1}{t}\left[f(\bx_i)-A(t)\right]$$`

where

`$$A(t)=(4\pi t)^{-\frac{d}{2}}\int\limits_{\calM}e^{\frac{||\bx_i-\bz||^2}{4t}}f(\bz)d\bz$$`

---

# Integral

- Can use approximation


`$$A(t)=\alpha\sum\limits_{\bx_j\in N(\bx_i)}w_{ij}f(\bx_j)$$`

- where `\(w_{ij}=e^{\frac{||\bx_i-\bx_j||^2}{4t}}\)`
--

- and `\(\alpha=k^{-1}(4\pi t)^{-\frac{d}{2}}\)`
--

- Think of this like a Monte Carlo estimate.


---

# Optimisation

- Putting together

`$$-\Delta f(\bx_i)\overset{\propto}{\sim}f(\bx_i)-\alpha\sum\limits_{\bx_j\in N(\bx_i)}w_{ij}f(\bx_j)d\bx_j$$`
--

- Aim is to minimise above expression, so multiplying by a constant can be ignored.
--

- All that is left is to complete a discrete approximation to the original objective function

---

# Matrices

- The adjacency matrix `\(\bA\)` has element `\(w_{ij}\)` on row `\(i\)` and column `\(j\)`.
--

- The degree matrix `\(\bD\)` is diagonal with `\(\sum_jw_{ij}\)` on row `\(i\)` and column `\(i\)`.
--

- The graph Laplacian for a weighted graph is given by `\(\bL=\bD-\bA\)`. 
--

- The matrix to be considered is `\(\bD^{-1}\bL\)`.
--
Why?

---
class: smallmath

# Row `\(i\)`

- Consider row `\(i\)` of `\(\bD^{-1}\bL\bff\)`
--

`$$\begin{bmatrix}\vdots&amp;\vdots&amp;\vdots&amp;\vdots&amp;\vdots&amp;\vdots&amp;\vdots\\\vdots&amp;w_{ij_1}&amp;\dots&amp;\sum_jw_{ij}&amp;\dots&amp;w_{ij_2}&amp;\vdots\\\vdots&amp;\vdots&amp;\vdots&amp;\vdots&amp;\vdots&amp;\vdots&amp;\vdots\\\end{bmatrix}\begin{bmatrix}\vdots\\f(\bx_{j_1})\\\vdots\\f(\bx_i)\\\vdots\\\vdots\\f(\bx_{j_2})\end{bmatrix}$$`
---

# In full

- Row `\(i\)` evalutes to

`$$(\sum_k w_{ij})f(\bx_j)-\sum_j w_{ij}f(\bx_j)$$`
--

- Premultiplying by `\(\bD^{-1}\)` is the same as dividing through by `\((\sum_k w_{ij})\)` yielding
--

`$$f(\bx_j)-\frac{1}{\sum_k w_{ij}}\sum_j w_{ij}f(\bx_j)$$`
---

# One last trick

- From earlier
--

`$$\Delta f(\bx_i)=f(\bx_i)-\alpha\sum_j w_{ij}f(\bx_j)$$`
--

- Need to show `\(\alpha=\frac{1}{\sum_k w_{ij}}\)`
--

- Consider `\(f\)` is a constant function `\(f(\bx)=c\)` for all `\(\bx\)`

---

# Constant Function

- If `\(f\)` is a constant function, Laplace Beltrami operator should be zero.
--
Why?
--

- Therefore
--

`$$\Delta f(\bx_i)=c-\alpha\sum_j w_{ij}c=0$$`
--

- Solving gives `\(\alpha=\frac{1}{\sum_j w_{ij}}\)`

---

# The End

- Putting everything together

`\(\bD^{-1}\bL\bff\approx f(\bx_i)-\alpha\sum_j w_{ij}f(\bx_j)\approx -\Delta f(\bx_i)\)`

- Minimising `\(-\int_\calM\Delta (f) f\)` is approximately the same as minimising `\(\bff'\bD^{-1}\bL\bff\)`.
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="libs/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"slideNumberFormat": "%current%",
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
