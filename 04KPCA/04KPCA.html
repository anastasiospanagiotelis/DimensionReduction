<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Dimension Reduction:Kernel PCA</title>
    <meta charset="utf-8" />
    <meta name="author" content="Anastasios Panagiotelis" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <script src="libs/htmlwidgets/htmlwidgets.js"></script>
    <script src="libs/rglWebGL-binding/rglWebGL.js"></script>
    <link href="libs/rglwidgetClass/rgl.css" rel="stylesheet" />
    <script src="libs/rglwidgetClass/rglClass.src.js"></script>
    <script src="libs/rglwidgetClass/utils.src.js"></script>
    <script src="libs/rglwidgetClass/buffer.src.js"></script>
    <script src="libs/rglwidgetClass/subscenes.src.js"></script>
    <script src="libs/rglwidgetClass/shaders.src.js"></script>
    <script src="libs/rglwidgetClass/textures.src.js"></script>
    <script src="libs/rglwidgetClass/projection.src.js"></script>
    <script src="libs/rglwidgetClass/mouse.src.js"></script>
    <script src="libs/rglwidgetClass/init.src.js"></script>
    <script src="libs/rglwidgetClass/pieces.src.js"></script>
    <script src="libs/rglwidgetClass/draw.src.js"></script>
    <script src="libs/rglwidgetClass/controls.src.js"></script>
    <script src="libs/rglwidgetClass/selection.src.js"></script>
    <script src="libs/rglwidgetClass/rglTimer.src.js"></script>
    <script src="libs/rglwidgetClass/pretty.src.js"></script>
    <script src="libs/rglwidgetClass/axes.src.js"></script>
    <script src="libs/rglwidgetClass/animation.src.js"></script>
    <!--html_preserve--><script type = "text/plain" id = "rgl-vertex-shader">
    #line 2 1
    // File 1 is the vertex shader
    #ifdef GL_ES
    #ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    #else
    precision mediump float;
    #endif
    #endif

    attribute vec3 aPos;
    attribute vec4 aCol;
    uniform mat4 mvMatrix;
    uniform mat4 prMatrix;
    varying vec4 vCol;
    varying vec4 vPosition;

    #ifdef NEEDS_VNORMAL
    attribute vec3 aNorm;
    uniform mat4 normMatrix;
    varying vec4 vNormal;
    #endif

    #if defined(HAS_TEXTURE) || defined (IS_TEXT)
    attribute vec2 aTexcoord;
    varying vec2 vTexcoord;
    #endif

    #ifdef FIXED_SIZE
    uniform vec3 textScale;
    #endif

    #ifdef FIXED_QUADS
    attribute vec3 aOfs;
    #endif

    #ifdef IS_TWOSIDED
    #ifdef HAS_NORMALS
    varying float normz;
    uniform mat4 invPrMatrix;
    #else
    attribute vec3 aPos1;
    attribute vec3 aPos2;
    varying float normz;
    #endif
    #endif // IS_TWOSIDED

    #ifdef FAT_LINES
    attribute vec3 aNext;
    attribute vec2 aPoint;
    varying vec2 vPoint;
    varying float vLength;
    uniform float uAspect;
    uniform float uLwd;
    #endif


    void main(void) {
      
    #ifndef IS_BRUSH
    #if defined(NCLIPPLANES) || !defined(FIXED_QUADS) || defined(HAS_FOG)
      vPosition = mvMatrix * vec4(aPos, 1.);
    #endif
      
    #ifndef FIXED_QUADS
      gl_Position = prMatrix * vPosition;
    #endif
    #endif // !IS_BRUSH
      
    #ifdef IS_POINTS
      gl_PointSize = POINTSIZE;
    #endif
      
      vCol = aCol;
      
    #ifdef NEEDS_VNORMAL
      vNormal = normMatrix * vec4(-aNorm, dot(aNorm, aPos));
    #endif
      
    #ifdef IS_TWOSIDED
    #ifdef HAS_NORMALS
      /* normz should be calculated *after* projection */
      normz = (invPrMatrix*vNormal).z;
    #else
      vec4 pos1 = prMatrix*(mvMatrix*vec4(aPos1, 1.));
      pos1 = pos1/pos1.w - gl_Position/gl_Position.w;
      vec4 pos2 = prMatrix*(mvMatrix*vec4(aPos2, 1.));
      pos2 = pos2/pos2.w - gl_Position/gl_Position.w;
      normz = pos1.x*pos2.y - pos1.y*pos2.x;
    #endif
    #endif // IS_TWOSIDED
      
    #ifdef NEEDS_VNORMAL
      vNormal = vec4(normalize(vNormal.xyz/vNormal.w), 1);
    #endif
      
    #if defined(HAS_TEXTURE) || defined(IS_TEXT)
      vTexcoord = aTexcoord;
    #endif
      
    #if defined(FIXED_SIZE) && !defined(ROTATING)
      vec4 pos = prMatrix * mvMatrix * vec4(aPos, 1.);
      pos = pos/pos.w;
      gl_Position = pos + vec4(aOfs*textScale, 0.);
    #endif
      
    #if defined(IS_SPRITES) && !defined(FIXED_SIZE)
      vec4 pos = mvMatrix * vec4(aPos, 1.);
      pos = pos/pos.w + vec4(aOfs,  0.);
      gl_Position = prMatrix*pos;
    #endif
      
    #ifdef FAT_LINES
      /* This code was inspired by Matt Deslauriers' code in 
       https://mattdesl.svbtle.com/drawing-lines-is-hard */
      vec2 aspectVec = vec2(uAspect, 1.0);
      mat4 projViewModel = prMatrix * mvMatrix;
      vec4 currentProjected = projViewModel * vec4(aPos, 1.0);
      currentProjected = currentProjected/currentProjected.w;
      vec4 nextProjected = projViewModel * vec4(aNext, 1.0);
      vec2 currentScreen = currentProjected.xy * aspectVec;
      vec2 nextScreen = (nextProjected.xy / nextProjected.w) * aspectVec;
      float len = uLwd;
      vec2 dir = vec2(1.0, 0.0);
      vPoint = aPoint;
      vLength = length(nextScreen - currentScreen)/2.0;
      vLength = vLength/(vLength + len);
      if (vLength > 0.0) {
        dir = normalize(nextScreen - currentScreen);
      }
      vec2 normal = vec2(-dir.y, dir.x);
      dir.x /= uAspect;
      normal.x /= uAspect;
      vec4 offset = vec4(len*(normal*aPoint.x*aPoint.y - dir), 0.0, 0.0);
      gl_Position = currentProjected + offset;
    #endif
      
    #ifdef IS_BRUSH
      gl_Position = vec4(aPos, 1.);
    #endif
    }
    </script>
    <script type = "text/plain" id = "rgl-fragment-shader">
    #line 2 2
    // File 2 is the fragment shader
    #ifdef GL_ES
    #ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    #else
    precision mediump float;
    #endif
    #endif
    varying vec4 vCol; // carries alpha
    varying vec4 vPosition;
    #if defined(HAS_TEXTURE) || defined (IS_TEXT)
    varying vec2 vTexcoord;
    uniform sampler2D uSampler;
    #endif

    #ifdef HAS_FOG
    uniform int uFogMode;
    uniform vec3 uFogColor;
    uniform vec4 uFogParms;
    #endif

    #if defined(IS_LIT) && !defined(FIXED_QUADS)
    varying vec4 vNormal;
    #endif

    #if NCLIPPLANES > 0
    uniform vec4 vClipplane[NCLIPPLANES];
    #endif

    #if NLIGHTS > 0
    uniform mat4 mvMatrix;
    #endif

    #ifdef IS_LIT
    uniform vec3 emission;
    uniform float shininess;
    #if NLIGHTS > 0
    uniform vec3 ambient[NLIGHTS];
    uniform vec3 specular[NLIGHTS]; // light*material
    uniform vec3 diffuse[NLIGHTS];
    uniform vec3 lightDir[NLIGHTS];
    uniform bool viewpoint[NLIGHTS];
    uniform bool finite[NLIGHTS];
    #endif
    #endif // IS_LIT

    #ifdef IS_TWOSIDED
    uniform bool front;
    varying float normz;
    #endif

    #ifdef FAT_LINES
    varying vec2 vPoint;
    varying float vLength;
    #endif

    void main(void) {
      vec4 fragColor;
    #ifdef FAT_LINES
      vec2 point = vPoint;
      bool neg = point.y < 0.0;
      point.y = neg ? (point.y + vLength)/(1.0 - vLength) :
                     -(point.y - vLength)/(1.0 - vLength);
    #if defined(IS_TRANSPARENT) && defined(IS_LINESTRIP)
      if (neg && length(point) <= 1.0) discard;
    #endif
      point.y = min(point.y, 0.0);
      if (length(point) > 1.0) discard;
    #endif // FAT_LINES
      
    #ifdef ROUND_POINTS
      vec2 coord = gl_PointCoord - vec2(0.5);
      if (length(coord) > 0.5) discard;
    #endif
      
    #if NCLIPPLANES > 0
      for (int i = 0; i < NCLIPPLANES; i++)
        if (dot(vPosition, vClipplane[i]) < 0.0) discard;
    #endif
        
    #ifdef FIXED_QUADS
        vec3 n = vec3(0., 0., 1.);
    #elif defined(IS_LIT)
        vec3 n = normalize(vNormal.xyz);
    #endif
        
    #ifdef IS_TWOSIDED
        if ((normz <= 0.) != front) discard;
    #endif
        
    #ifdef IS_LIT
        vec3 eye = normalize(-vPosition.xyz/vPosition.w);
        vec3 lightdir;
        vec4 colDiff;
        vec3 halfVec;
        vec4 lighteffect = vec4(emission, 0.);
        vec3 col;
        float nDotL;
    #ifdef FIXED_QUADS
        n = -faceforward(n, n, eye);
    #endif
        
    #if NLIGHTS > 0
        for (int i=0;i<NLIGHTS;i++) {
          colDiff = vec4(vCol.rgb * diffuse[i], vCol.a);
          lightdir = lightDir[i];
          if (!viewpoint[i])
            lightdir = (mvMatrix * vec4(lightdir, 1.)).xyz;
          if (!finite[i]) {
            halfVec = normalize(lightdir + eye);
          } else {
            lightdir = normalize(lightdir - vPosition.xyz/vPosition.w);
            halfVec = normalize(lightdir + eye);
          }
          col = ambient[i];
          nDotL = dot(n, lightdir);
          col = col + max(nDotL, 0.) * colDiff.rgb;
          col = col + pow(max(dot(halfVec, n), 0.), shininess) * specular[i];
          lighteffect = lighteffect + vec4(col, colDiff.a);
        }
    #endif
        
    #else // not IS_LIT
        vec4 colDiff = vCol;
        vec4 lighteffect = colDiff;
    #endif
        
    #ifdef IS_TEXT
        vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);
    #endif
        
    #ifdef HAS_TEXTURE
    #ifdef TEXTURE_rgb
        vec4 textureColor = lighteffect*vec4(texture2D(uSampler, vTexcoord).rgb, 1.);
    #endif
        
    #ifdef TEXTURE_rgba
        vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);
    #endif
        
    #ifdef TEXTURE_alpha
        vec4 textureColor = texture2D(uSampler, vTexcoord);
        float luminance = dot(vec3(1.,1.,1.), textureColor.rgb)/3.;
        textureColor =  vec4(lighteffect.rgb, lighteffect.a*luminance);
    #endif
        
    #ifdef TEXTURE_luminance
        vec4 textureColor = vec4(lighteffect.rgb*dot(texture2D(uSampler, vTexcoord).rgb, vec3(1.,1.,1.))/3., lighteffect.a);
    #endif
        
    #ifdef TEXTURE_luminance_alpha
        vec4 textureColor = texture2D(uSampler, vTexcoord);
        float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;
        textureColor = vec4(lighteffect.rgb*luminance, lighteffect.a*textureColor.a);
    #endif
        
        fragColor = textureColor;

    #elif defined(IS_TEXT)
        if (textureColor.a < 0.1)
          discard;
        else
          fragColor = textureColor;
    #else
        fragColor = lighteffect;
    #endif // HAS_TEXTURE
        
    #ifdef HAS_FOG
        // uFogParms elements: x = near, y = far, z = fogscale, w = (1-sin(FOV/2))/(1+sin(FOV/2))
        // In Exp and Exp2: use density = density/far
        // fogF will be the proportion of fog
        // Initialize it to the linear value
        float fogF;
        if (uFogMode > 0) {
          fogF = (uFogParms.y - vPosition.z/vPosition.w)/(uFogParms.y - uFogParms.x);
          if (uFogMode > 1)
            fogF = mix(uFogParms.w, 1.0, fogF);
          fogF = fogF*uFogParms.z;
          if (uFogMode == 2)
            fogF = 1.0 - exp(-fogF);
          // Docs are wrong: use (density*c)^2, not density*c^2
          // https://gitlab.freedesktop.org/mesa/mesa/-/blob/master/src/mesa/swrast/s_fog.c#L58
          else if (uFogMode == 3)
            fogF = 1.0 - exp(-fogF*fogF);
          fogF = clamp(fogF, 0.0, 1.0);
          gl_FragColor = vec4(mix(fragColor.rgb, uFogColor, fogF), fragColor.a);
        } else gl_FragColor = fragColor;
    #else
        gl_FragColor = fragColor;
    #endif // HAS_FOG
        
    }
    </script><!--/html_preserve-->
    <script src="libs/CanvasMatrix4/CanvasMatrix.src.js"></script>
    <link rel="stylesheet" href="../css/mtheme.css" type="text/css" />
    <link rel="stylesheet" href="../css/mod.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Dimension Reduction:</br>Kernel PCA
]
.author[
### Anastasios Panagiotelis
]
.institute[
### University of Sydney
]

---

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
    Macros: {
      bA: "{\\mathbf{A}}",
      bC: "{\\mathbf{C}}",
      bv: "{\\mathbf{v}}",
      bw: "{\\mathbf{w}}",
      bx: "{\\mathbf{x}}",
      bX: "{\\mathbf{X}}",
      by: "{\\mathbf{y}}",
      bY: "{\\mathbf{Y}}",
      bw: "{\\mathbf{w}}",
      bW: "{\\mathbf{W}}",
      bK: "{\\mathbf{K}}",
      bz: "{\\mathbf{z}}",
      bU: "{\\mathbf{U}}",
      bS: "{\\mathbf{S}}",
      bff: "{\\mathbf{f}}",
      bD: "{\\mathbf{D}}",
      bL: "{\\mathbf{L}}",
      calL: "{\\mathcal{L}}",
      calM: "{\\mathcal{M}}",
      bbR: "{\\mathbb{R}}",
      bB: "{\\mathbf{B}}",
      bbb: "{\\mathbf{b}}",
      bLambda: "{\\boldsymbol{\\Lambda}}",
      bDelta: "{\\boldsymbol{\\Delta}}",
      bH: "{\\mathbf{H}}",
      bI: "{\\mathbf{I}}",
      biota: "{\\boldsymbol{\\iota}}",
      bN: "{\\mathbf{N}}",
      bQ: "{\\mathbf{Q}}"
      }
  }
});
</script>

# Outline

- Feature mapping
--

  + Why we sometimes need to go to higher dimensions to get to lower dimensions.
--

- Kernel trick
--

  + How we can compute inner products of high (even infinite) dimensional transformations of the data using only our original data
--

- Kernel PCA algorithm
--

  + Using this for PCA.




---

class: center, middle, inverse

# Feature Mapping

---

# Non linear PCA

- Regular PCA gives principal components that are linear functions of the data.
--

- As a rough idea consider including polynomials `\(x^2, x^3,x^4,\dots\)` as well as cross products.
--

- In general, let `\(\Phi:\bbR^p\rightarrow\bbR^P\)` where `\(P&gt;p\)` be a feature map.
--

- Rather than carry out principal components on `\(\bx\)`, carry out principal components on `\(\Phi(\bx)\)`

---

# Question

- Aren't we doing dimension reduction?
--

- Yes, however the idea is that a linear algorithm (like PCA) can only reveal patterns if we transform to a higher dimension first.
--

- Consider this example

---

# Circles

&lt;img src="04KPCA_files/figure-html/unnamed-chunk-1-1.png" style="display: block; margin: auto;" /&gt;

---

# Circles example

- Suppose we use PCA to go from 2 dimensions to 1 dimension.
--

- Since PCA can only rotate the data, there is no way to separate out the black and yellow points.
--

- This may be an important feature that we want to identify in lower dimensional space.

---

# First PC of circles example


&lt;img src="04KPCA_files/figure-html/unnamed-chunk-2-1.png" style="display: block; margin: auto;" /&gt;

---

# Add dimension

- Consider adding a new variable given by `\(x_3=x_1^2+x_2^2\)`
--

- Then we we carry out PCA on `\(x_1\)`, `\(x_2\)` and `\(x_3\)`
--

- Will the first principal component separate out the black and yellow points.

---

# More dimensions

<div id="rgl15437" style="width:504px;height:504px;" class="rglWebGL html-widget"></div>
<script type="application/json" data-for="rgl15437">{"x":{"material":{"color":"#000000","alpha":1,"lit":true,"ambient":"#000000","specular":"#FFFFFF","emission":"#000000","shininess":50,"smooth":true,"front":"filled","back":"filled","size":3,"lwd":1,"fog":true,"point_antialias":false,"line_antialias":false,"texture":null,"textype":"rgb","texmipmap":false,"texminfilter":"linear","texmagfilter":"linear","texenvmap":false,"depth_mask":true,"depth_test":"less","isTransparent":false,"polygon_offset":[0,0],"margin":"","floating":false,"tag":"","blend":["src_alpha","one_minus_src_alpha"]},"rootSubscene":1,"objects":{"7":{"id":7,"type":"points","material":{"lit":false},"vertices":"0","colors":"1","centers":"2","ignoreExtent":false,"flags":34816},"9":{"id":9,"type":"text","material":{"lit":false,"margin":0,"floating":true,"edge":[0,1,1]},"vertices":"3","colors":"4","texts":[["x1"]],"cex":[[1]],"adj":[[0.5,0.5,0.5]],"centers":"5","family":[["sans"]],"font":[[1]],"ignoreExtent":true,"flags":33808},"10":{"id":10,"type":"text","material":{"lit":false,"margin":1,"floating":true,"edge":[1,1,1]},"vertices":"6","colors":"7","texts":[["x2"]],"cex":[[1]],"adj":[[0.5,0.5,0.5]],"centers":"8","family":[["sans"]],"font":[[1]],"ignoreExtent":true,"flags":33808},"11":{"id":11,"type":"text","material":{"lit":false,"margin":2,"floating":true,"edge":[1,1,1]},"vertices":"9","colors":"10","texts":[["x3"]],"cex":[[1]],"adj":[[0.5,0.5,0.5]],"centers":"11","family":[["sans"]],"font":[[1]],"ignoreExtent":true,"flags":33808},"5":{"id":5,"type":"light","vertices":[[0,0,1]],"colors":[[1,1,1,1],[1,1,1,1],[1,1,1,1]],"viewpoint":true,"finite":false},"4":{"id":4,"type":"background","material":{},"colors":"12","centers":"13","sphere":false,"fogtype":"none","fogscale":1,"flags":32768},"6":{"id":6,"type":"background","material":{"lit":false,"back":"lines"},"colors":"14","centers":"15","sphere":false,"fogtype":"none","fogscale":1,"flags":32768},"8":{"id":8,"type":"bboxdeco","material":{"front":"lines","back":"lines"},"vertices":"16","colors":"17","axes":{"mode":["pretty","pretty","pretty"],"step":[1,1,1],"nticks":[5,5,5],"marklen":[15,15,15],"expand":[1.02999997138977,1.02999997138977,1.02999997138977]},"draw_front":true,"flags":32769},"1":{"id":1,"type":"subscene","par3d":{"antialias":8,"FOV":30,"ignoreExtent":false,"listeners":1,"mouseMode":{"none":"none","left":"trackball","right":"zoom","middle":"fov","wheel":"pull"},"observer":[0,0,22.3294124603271],"modelMatrix":[[1.13475549221039,0,0,0.181127294898033],[0,0.289247751235962,1.03442811965942,-0.934143900871277],[0,-0.79470157623291,0.376501053571701,-19.8654499053955],[0,0,0,1]],"projMatrix":[[3.73205089569092,0,0,0],[0,3.73205089569092,0,0],[0,0,-3.86370325088501,-80.4949493408203],[0,0,-1,0]],"skipRedraw":false,"userMatrix":[[1,0,0,0],[0,0.342020143325668,0.939692620785909,0],[0,-0.939692620785909,0.342020143325668,0],[0,0,0,1]],"userProjection":[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],"scale":[1.13475549221039,0.845703780651093,1.10081541538239],"viewport":{"x":0,"y":0,"width":1,"height":1},"zoom":1,"bbox":[-2.48100852966309,2.16177296638489,0.000772124156355858,6.23040246963501,-2.36109328269958,2.42483353614807],"windowRect":[0,0,256,256],"family":"sans","font":1,"cex":1,"useFreeType":true,"fontname":"NULL","maxClipPlanes":2147483647,"glVersion":"NA","activeSubscene":0},"embeddings":{"viewport":"replace","projection":"replace","model":"replace","mouse":"replace"},"objects":[6,8,7,9,10,11,5],"subscenes":[],"flags":36113}},"crosstalk":{"key":[],"group":[],"id":[],"options":[]},"width":504,"height":504,"buffer":{"accessors":[{"bufferView":0,"componentType":5126,"count":200,"type":"VEC3"},{"bufferView":1,"componentType":5121,"count":200,"type":"VEC4","normalized":true},{"bufferView":2,"componentType":5126,"count":200,"type":"VEC3"},{"bufferView":3,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":4,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":5,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":6,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":7,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":8,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":9,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":10,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":11,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":12,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":13,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":14,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":15,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":16,"componentType":5126,"count":16,"type":"VEC3"},{"bufferView":17,"componentType":5121,"count":1,"type":"VEC4"}],"bufferViews":[{"buffer":0,"byteLength":2400,"byteOffset":0},{"buffer":0,"byteLength":800,"byteOffset":2400},{"buffer":0,"byteLength":2400,"byteOffset":3200},{"buffer":0,"byteLength":12,"byteOffset":5600},{"buffer":0,"byteLength":4,"byteOffset":5612},{"buffer":0,"byteLength":12,"byteOffset":5616},{"buffer":0,"byteLength":12,"byteOffset":5628},{"buffer":0,"byteLength":4,"byteOffset":5640},{"buffer":0,"byteLength":12,"byteOffset":5644},{"buffer":0,"byteLength":12,"byteOffset":5656},{"buffer":0,"byteLength":4,"byteOffset":5668},{"buffer":0,"byteLength":12,"byteOffset":5672},{"buffer":0,"byteLength":16,"byteOffset":5684},{"buffer":0,"byteLength":3,"byteOffset":5700},{"buffer":0,"byteLength":4,"byteOffset":5703},{"buffer":0,"byteLength":3,"byteOffset":5707},{"buffer":0,"byteLength":192,"byteOffset":5712},{"buffer":0,"byteLength":4,"byteOffset":5904}],"buffers":[{"byteLength":5908,"bytes":"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\nl/nqv26Ea0B3iQ4/2MgewHT5xEDMQOG7IRVAP2pvS0ADBM8/9qoTwNBmsEBCg96+AEu0Pwg5\nIEDtgzg/ggLUvvU+tkCpahZAU3bqPlzdeEC8gfU/LKmyvo21JUBIEMk/oYC5Px8ZV0ABt4+/\nyyMNwCDVrkBNUUY/gGKqPn0PSkCMad+/ZHLDPwZii0CHHLa/GqP/v+y6rkBgR5s/Cim5P1D8\nHUCU+Bw/EkWQv4FFm0AWQPI/UwK5vuy2mkDBzwrANoGDv4TbdkBhP9Y/Oz+pv+MbcEARLLW/\nrkuOPxQViEDhUd6/4ELAP5K4vEBqQfS/Od6rvx6mP0D6uYs/WiChv7S8PUCaXpY/laHCP5D7\na0DRGZa/taOQv7UnV0Bn0ri/HqsHvj70skAnHBfASGGpv+QHNEAS54O/CUjRP95KfkAf8pG/\nuggGv6NSbkDtvO0/xaM+P6FbiEDubvY/cq3QP+fElECpnrS/sZcewFiVxEDMAFW9fsqeP0MG\nQEDMvJq/sSYmP3zyQUAWws4/HGPvPYnQqECazhLALXe+vmT5rUDGUBPAncDBPzmeJkAZBw+/\n0KMWwEkswkCt+jm/7cnIvtCsLUCPy8y/bi2hv4jlLEBKN4c/TiP6Pzc3vEBD17c/JZDmP/Pm\ngEBlnWK/laKvvhtEL0BSOM8/qEvHv1ujWkDE+H6/MZ3UP0NGlUDbs7A/KMV5P8sUUkCZaMO/\nFlFEv6lpW0ADuNc/FuqsPgrJLUBpcs6/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAA\nAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/\nAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAA\nAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/\nAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAA\nAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/\nAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAA\nAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/+afAP/mnwD/\n5p8A/+afAP/mnwD/5p8A/+afAP/mnwD/5p8A/+afAP/mnwD/5p8A/+afAP/mnwD/5p8A/+af\nAP/mnwD/5p8A/+afAP/mnwD/5p8A/+afAP/mnwD/5p8A/+afAP/mnwD/5p8A/+afAP/mnwD/\n5p8A/+afAP/mnwD/5p8A/+afAP/mnwD/5p8A/+afAP/mnwD/5p8A/+afAP/mnwD/5p8A/+af\nAP/mnwD/5p8A/+afAP/mnwD/5p8A/+afAP/mnwD/5p8A/+afAP/mnwD/5p8A/+afAP/mnwD/\n5p8A/+afAP/mnwD/5p8A/+afAP/mnwD/5p8A/+afAP/mnwD/5p8A/+afAP/mnwD/5p8A/+af\nAP/mnwD/5p8A/+afAP/mnwD/5p8A/+afAP/mnwD/5p8A/+afAP/mnwD/5p8A/+afAP/mnwD/\n5p8A/+afAP/mnwD/5p8A/+afAP/mnwD/5p8A/+afAP/mnwD/5p8A/+afAP/mnwD/5p8A/+af\nAP/mnwD/5p8A/+afAP8HNNW8Y46SPYBQiD7xbRu++c9DPaomIT7qW+2+k76IPtDeab4k22Y+\nEiSUPb4tFr4G1109U3AGPVMIMT6ANtU+CrCJPpE6nr6DdAc/uymiPi1RRL6snIy9oKeIPCcL\n4L0lxTS+fZqGPaddPr5mHSo/SvMDP74kiz4cb4Y+hZ9sP7HDbD/9oTY9Rk0kPBqjtz13n5a+\nTR8VP4hJNL89ITW/SQ1mP2WCIT/DeNA9yY8rP6vxT79F1J2+g6bCPTgIkjsiZwa+SQrYPsHc\nIr9TvnM/y6xoP5eARr3IBDK/8NtoP70YJz/S8m49R7jsPdV8q75ReHY+mBeNPSRm1r18rx89\ni0HgPISnJD7JFz++CZHUPap1hr4wCrg+kjyFPvxTuT7zWMy9P41aPxUnaz+eccW+QayFPvmg\nqz5/b4M+UuyHPYVZsTwWqgy9iXcNOwctAD2DJpI+WssyPtI9nL49Geu+n7Q6P1dVOD8JqLC+\n9ez2PaTMHz2YNtq9rIiNPCyinb1VlL++L5sPPtLreDwJPXw+SyHMPv/VFD8VoTo+PtAbPpOU\nsL41E62+FYDzPnzhGb9ft0E+U1nzPh+3Kb89O90+/6adPiZBsj4arZC9ygE9PkX52L6BssS+\n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\nwH8AAIA/AADAfwAAwH8AAABAAAAAAQ=="}]},"context":{"shiny":false,"rmarkdown":"xaringan::moon_reader"},"vertexShader":"#line 2 1\n// File 1 is the vertex shader\n#ifdef GL_ES\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#endif\n\nattribute vec3 aPos;\nattribute vec4 aCol;\nuniform mat4 mvMatrix;\nuniform mat4 prMatrix;\nvarying vec4 vCol;\nvarying vec4 vPosition;\n\n#ifdef NEEDS_VNORMAL\nattribute vec3 aNorm;\nuniform mat4 normMatrix;\nvarying vec4 vNormal;\n#endif\n\n#if defined(HAS_TEXTURE) || defined (IS_TEXT)\nattribute vec2 aTexcoord;\nvarying vec2 vTexcoord;\n#endif\n\n#ifdef FIXED_SIZE\nuniform vec3 textScale;\n#endif\n\n#ifdef FIXED_QUADS\nattribute vec3 aOfs;\n#endif\n\n#ifdef IS_TWOSIDED\n#ifdef HAS_NORMALS\nvarying float normz;\nuniform mat4 invPrMatrix;\n#else\nattribute vec3 aPos1;\nattribute vec3 aPos2;\nvarying float normz;\n#endif\n#endif // IS_TWOSIDED\n\n#ifdef FAT_LINES\nattribute vec3 aNext;\nattribute vec2 aPoint;\nvarying vec2 vPoint;\nvarying float vLength;\nuniform float uAspect;\nuniform float uLwd;\n#endif\n\n\nvoid main(void) {\n  \n#ifndef IS_BRUSH\n#if defined(NCLIPPLANES) || !defined(FIXED_QUADS) || defined(HAS_FOG)\n  vPosition = mvMatrix * vec4(aPos, 1.);\n#endif\n  \n#ifndef FIXED_QUADS\n  gl_Position = prMatrix * vPosition;\n#endif\n#endif // !IS_BRUSH\n  \n#ifdef IS_POINTS\n  gl_PointSize = POINTSIZE;\n#endif\n  \n  vCol = aCol;\n  \n#ifdef NEEDS_VNORMAL\n  vNormal = normMatrix * vec4(-aNorm, dot(aNorm, aPos));\n#endif\n  \n#ifdef IS_TWOSIDED\n#ifdef HAS_NORMALS\n  /* normz should be calculated *after* projection */\n  normz = (invPrMatrix*vNormal).z;\n#else\n  vec4 pos1 = prMatrix*(mvMatrix*vec4(aPos1, 1.));\n  pos1 = pos1/pos1.w - gl_Position/gl_Position.w;\n  vec4 pos2 = prMatrix*(mvMatrix*vec4(aPos2, 1.));\n  pos2 = pos2/pos2.w - gl_Position/gl_Position.w;\n  normz = pos1.x*pos2.y - pos1.y*pos2.x;\n#endif\n#endif // IS_TWOSIDED\n  \n#ifdef NEEDS_VNORMAL\n  vNormal = vec4(normalize(vNormal.xyz/vNormal.w), 1);\n#endif\n  \n#if defined(HAS_TEXTURE) || defined(IS_TEXT)\n  vTexcoord = aTexcoord;\n#endif\n  \n#if defined(FIXED_SIZE) && !defined(ROTATING)\n  vec4 pos = prMatrix * mvMatrix * vec4(aPos, 1.);\n  pos = pos/pos.w;\n  gl_Position = pos + vec4(aOfs*textScale, 0.);\n#endif\n  \n#if defined(IS_SPRITES) && !defined(FIXED_SIZE)\n  vec4 pos = mvMatrix * vec4(aPos, 1.);\n  pos = pos/pos.w + vec4(aOfs,  0.);\n  gl_Position = prMatrix*pos;\n#endif\n  \n#ifdef FAT_LINES\n  /* This code was inspired by Matt Deslauriers' code in \n   https://mattdesl.svbtle.com/drawing-lines-is-hard */\n  vec2 aspectVec = vec2(uAspect, 1.0);\n  mat4 projViewModel = prMatrix * mvMatrix;\n  vec4 currentProjected = projViewModel * vec4(aPos, 1.0);\n  currentProjected = currentProjected/currentProjected.w;\n  vec4 nextProjected = projViewModel * vec4(aNext, 1.0);\n  vec2 currentScreen = currentProjected.xy * aspectVec;\n  vec2 nextScreen = (nextProjected.xy / nextProjected.w) * aspectVec;\n  float len = uLwd;\n  vec2 dir = vec2(1.0, 0.0);\n  vPoint = aPoint;\n  vLength = length(nextScreen - currentScreen)/2.0;\n  vLength = vLength/(vLength + len);\n  if (vLength > 0.0) {\n    dir = normalize(nextScreen - currentScreen);\n  }\n  vec2 normal = vec2(-dir.y, dir.x);\n  dir.x /= uAspect;\n  normal.x /= uAspect;\n  vec4 offset = vec4(len*(normal*aPoint.x*aPoint.y - dir), 0.0, 0.0);\n  gl_Position = currentProjected + offset;\n#endif\n  \n#ifdef IS_BRUSH\n  gl_Position = vec4(aPos, 1.);\n#endif\n}","fragmentShader":"#line 2 2\n// File 2 is the fragment shader\n#ifdef GL_ES\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#endif\nvarying vec4 vCol; // carries alpha\nvarying vec4 vPosition;\n#if defined(HAS_TEXTURE) || defined (IS_TEXT)\nvarying vec2 vTexcoord;\nuniform sampler2D uSampler;\n#endif\n\n#ifdef HAS_FOG\nuniform int uFogMode;\nuniform vec3 uFogColor;\nuniform vec4 uFogParms;\n#endif\n\n#if defined(IS_LIT) && !defined(FIXED_QUADS)\nvarying vec4 vNormal;\n#endif\n\n#if NCLIPPLANES > 0\nuniform vec4 vClipplane[NCLIPPLANES];\n#endif\n\n#if NLIGHTS > 0\nuniform mat4 mvMatrix;\n#endif\n\n#ifdef IS_LIT\nuniform vec3 emission;\nuniform float shininess;\n#if NLIGHTS > 0\nuniform vec3 ambient[NLIGHTS];\nuniform vec3 specular[NLIGHTS]; // light*material\nuniform vec3 diffuse[NLIGHTS];\nuniform vec3 lightDir[NLIGHTS];\nuniform bool viewpoint[NLIGHTS];\nuniform bool finite[NLIGHTS];\n#endif\n#endif // IS_LIT\n\n#ifdef IS_TWOSIDED\nuniform bool front;\nvarying float normz;\n#endif\n\n#ifdef FAT_LINES\nvarying vec2 vPoint;\nvarying float vLength;\n#endif\n\nvoid main(void) {\n  vec4 fragColor;\n#ifdef FAT_LINES\n  vec2 point = vPoint;\n  bool neg = point.y < 0.0;\n  point.y = neg ? (point.y + vLength)/(1.0 - vLength) :\n                 -(point.y - vLength)/(1.0 - vLength);\n#if defined(IS_TRANSPARENT) && defined(IS_LINESTRIP)\n  if (neg && length(point) <= 1.0) discard;\n#endif\n  point.y = min(point.y, 0.0);\n  if (length(point) > 1.0) discard;\n#endif // FAT_LINES\n  \n#ifdef ROUND_POINTS\n  vec2 coord = gl_PointCoord - vec2(0.5);\n  if (length(coord) > 0.5) discard;\n#endif\n  \n#if NCLIPPLANES > 0\n  for (int i = 0; i < NCLIPPLANES; i++)\n    if (dot(vPosition, vClipplane[i]) < 0.0) discard;\n#endif\n    \n#ifdef FIXED_QUADS\n    vec3 n = vec3(0., 0., 1.);\n#elif defined(IS_LIT)\n    vec3 n = normalize(vNormal.xyz);\n#endif\n    \n#ifdef IS_TWOSIDED\n    if ((normz <= 0.) != front) discard;\n#endif\n    \n#ifdef IS_LIT\n    vec3 eye = normalize(-vPosition.xyz/vPosition.w);\n    vec3 lightdir;\n    vec4 colDiff;\n    vec3 halfVec;\n    vec4 lighteffect = vec4(emission, 0.);\n    vec3 col;\n    float nDotL;\n#ifdef FIXED_QUADS\n    n = -faceforward(n, n, eye);\n#endif\n    \n#if NLIGHTS > 0\n    for (int i=0;i<NLIGHTS;i++) {\n      colDiff = vec4(vCol.rgb * diffuse[i], vCol.a);\n      lightdir = lightDir[i];\n      if (!viewpoint[i])\n        lightdir = (mvMatrix * vec4(lightdir, 1.)).xyz;\n      if (!finite[i]) {\n        halfVec = normalize(lightdir + eye);\n      } else {\n        lightdir = normalize(lightdir - vPosition.xyz/vPosition.w);\n        halfVec = normalize(lightdir + eye);\n      }\n      col = ambient[i];\n      nDotL = dot(n, lightdir);\n      col = col + max(nDotL, 0.) * colDiff.rgb;\n      col = col + pow(max(dot(halfVec, n), 0.), shininess) * specular[i];\n      lighteffect = lighteffect + vec4(col, colDiff.a);\n    }\n#endif\n    \n#else // not IS_LIT\n    vec4 colDiff = vCol;\n    vec4 lighteffect = colDiff;\n#endif\n    \n#ifdef IS_TEXT\n    vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);\n#endif\n    \n#ifdef HAS_TEXTURE\n#ifdef TEXTURE_rgb\n    vec4 textureColor = lighteffect*vec4(texture2D(uSampler, vTexcoord).rgb, 1.);\n#endif\n    \n#ifdef TEXTURE_rgba\n    vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);\n#endif\n    \n#ifdef TEXTURE_alpha\n    vec4 textureColor = texture2D(uSampler, vTexcoord);\n    float luminance = dot(vec3(1.,1.,1.), textureColor.rgb)/3.;\n    textureColor =  vec4(lighteffect.rgb, lighteffect.a*luminance);\n#endif\n    \n#ifdef TEXTURE_luminance\n    vec4 textureColor = vec4(lighteffect.rgb*dot(texture2D(uSampler, vTexcoord).rgb, vec3(1.,1.,1.))/3., lighteffect.a);\n#endif\n    \n#ifdef TEXTURE_luminance_alpha\n    vec4 textureColor = texture2D(uSampler, vTexcoord);\n    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\n    textureColor = vec4(lighteffect.rgb*luminance, lighteffect.a*textureColor.a);\n#endif\n    \n    fragColor = textureColor;\n\n#elif defined(IS_TEXT)\n    if (textureColor.a < 0.1)\n      discard;\n    else\n      fragColor = textureColor;\n#else\n    fragColor = lighteffect;\n#endif // HAS_TEXTURE\n    \n#ifdef HAS_FOG\n    // uFogParms elements: x = near, y = far, z = fogscale, w = (1-sin(FOV/2))/(1+sin(FOV/2))\n    // In Exp and Exp2: use density = density/far\n    // fogF will be the proportion of fog\n    // Initialize it to the linear value\n    float fogF;\n    if (uFogMode > 0) {\n      fogF = (uFogParms.y - vPosition.z/vPosition.w)/(uFogParms.y - uFogParms.x);\n      if (uFogMode > 1)\n        fogF = mix(uFogParms.w, 1.0, fogF);\n      fogF = fogF*uFogParms.z;\n      if (uFogMode == 2)\n        fogF = 1.0 - exp(-fogF);\n      // Docs are wrong: use (density*c)^2, not density*c^2\n      // https://gitlab.freedesktop.org/mesa/mesa/-/blob/master/src/mesa/swrast/s_fog.c#L58\n      else if (uFogMode == 3)\n        fogF = 1.0 - exp(-fogF*fogF);\n      fogF = clamp(fogF, 0.0, 1.0);\n      gl_FragColor = vec4(mix(fragColor.rgb, uFogColor, fogF), fragColor.a);\n    } else gl_FragColor = fragColor;\n#else\n    gl_FragColor = fragColor;\n#endif // HAS_FOG\n    \n}","players":[],"webGLoptions":{"preserveDrawingBuffer":true}},"evals":[],"jsHooks":[]}</script>

---

# First PC with extra feature

&lt;img src="04KPCA_files/figure-html/unnamed-chunk-4-1.png" style="display: block; margin: auto;" /&gt;

---

# Problems

- How to compute feature space?
--

- Will this be computationally feasible?
--

- There is a trick we can use so that we never have to compute the feature space
--

- This is known as the 'kernel' trick and is pervasive in machine learning.

---

class: inverse, middle, center

# The kernel trick

---

# The kernel trick

- Consider `\(\Phi(\bx)\)` which is an `\(P\)` dimensional vector.
--

- In many algorithms (including PCA) the solution can be reworked in terms of `\(\langle\Phi(\bx),\Phi(\bz)\rangle\)` (or if you prefer `\(\Phi(\bx)'\Phi(\bz)\)`).
--

- The inner product in the feature space, can be written as a function of `\(\bx\)` and `\(\bz\)`, known as the kernel
`$$\langle\Phi(\bx),\Phi(\bz)\rangle=K(\bx,\bz)$$`


---

# An example

- Consider the mapping `\(\Phi(\bx)=\left(x_1^2,\dots,x_p^2,\right.\)`--
`\(\sqrt{2}x_1x_2,\dots,\sqrt{2}x_{p-1}x_p,\)`--
`\(\sqrt{2}x_1,\dots,\sqrt{2}x_p,\)`--
`\(\left.1\right)\)`
--

- We have gone from an `\(p\)`-dimensional vector to a `\(P=(p(p+3))/2)+1\)` dimensional vector.
--

- The kernel function is

`$$K(\bx,\bz)=(\langle\bx,\bz\rangle+1)^2=\langle\Phi(\bx),\Phi(\bz)\rangle$$`
--

- This is called a polynomial kernel.

---

# Other kernels

- Other kernels are available
--

  + RBF kernel
  + Hyperbolic tangent kernel
--

- These may provide the inner product for infinite dimensional feature spaces.
--

- The feature space may not be unique.

---

class: inverse, middle, center

# Kernel PCA

---

# A PCA refresher

- The standard way to do PCA is to solve the eigenvalue problem
--

`$$\bS\bv=\lambda\bv$$`
--

- This is equivalent to
--

`$$\frac{1}{n-1}\bX'\bX\bv=\lambda\bv$$`
- The principal components are given by `\(\bX\bv\)` (not by `\(\bv\)`).

---

# A silly way to do PCA

- Take
--

`$$\frac{1}{n-1}\bX'\bX\bv=\lambda\bv$$`
--

- Pre-multiply by `\(\bX\)` and rearrange
--

`$$\bX\bX'\bX\bv=(n-1)\lambda\bX\bv$$`
- Replace `\(\bX\bv\)` with `\(\by\)` and `\((n-1)\lambda\)` with `\(\tilde{\lambda}\)`
--

`$$\bX\bX'\by=\tilde{\lambda}\by$$`

---

# Kernel matrix

-  Principal components could be found by finding eigenvectors of `\(\bX\bX'\)` instead of `\(\frac{1}{n}\bX'\bX\)`.
--

- Normally you wouldn't do this since `\(\bX\bX'\)` will be a bigger matrix than `\(\bX'\bX\)`
--

- Unless...
--
rather than `\(\bX\)` with rows `\(\bx_i\)` you have a matrix with rows `\(\Phi(\bx_i)\)`.
--

 + Then `\(\bX\bX'\)` becomes `\(\bK\)`.
--

 + Here `\(\bK\)` is the **kernel matrix** an `\(n\times n\)` matrix with elements `\(K(\bx_i,\bx_j)\)`.
 
---

# Some caveats

- That is a simpler treatment than what you will find in many references.
--

- A more formal treatment has to deal more carefully with the possible infinite dimensionality of the feature space.
--

- Care must be taken to center `\(\bK\)` by pre and post multiplying by the centering matrix `\(\bI-n^{-1}\iota\iota'\)`  
--

- Some sources will rescale the eigenvectors of `\(\bK\)` by `\(n-1\)` or `\(\lambda\)`.

---

# Demonstration

- Recall the world bank data.
--

- This data was analysed using PCA.
--

- On the following slide, the PCA output will be shown again
--

- After that we will work through applying kernel PCA to the same dataset.

---

# Standard PCA


&lt;img src="04KPCA_files/figure-html/unnamed-chunk-5-1.png" style="display: block; margin: auto;" /&gt;

---

# The dimRed package

- The [`dimRed` package](https://github.com/gdkrmr/dimRed) provides a unified framework for many dimension reduction techniques.
--

- It uses an S4 class for handling data with two slots
--

  + The slot `data` contains data (measures of development)
  + The slot `meta` contains other information (country names)

---

# Kernel PCA in dimRed

- By default dimRed uses the radial basis kernel
--

`$$K(\bx,\bz)=\exp\left(-\frac{||\bx-\bz||^2}{2\sigma^2}\right)$$`
--

- The default value of the tuning parameter is `\(\sigma=0.1\)`

---

# Code


```r
library(tidyverse)
library(dimRed)
read_csv('../data/WorldBankClean.csv')%&gt;% #Read Data
  mutate_if(is.numeric,scale)%&gt;% #Scale Data
  as.dimRedData(`Country Name` + `Country Code`~.,data=.)-&gt;wb #Convert to S4 class
  
kpcaout &lt;- embed(.data = wb, .method="kPCA")

df&lt;-tibble(cbind(kpcaout@data@meta,kpcaout@data@data)) # Convert back to a dataframe

ggplot(df,aes(x=kPCA1,y=kPCA2,label=`Country Code`))+geom_text(size=2) #Plot
```

---

# Kernel PCA

&lt;img src="04KPCA_files/figure-html/unnamed-chunk-7-1.png" style="display: block; margin: auto;" /&gt;

---

# With different tuning parameter


```r
kpcaout &lt;- embed(.data = wb, .method="kPCA",kpar=list(sigma=0.001))
```

&lt;img src="04KPCA_files/figure-html/unnamed-chunk-9-1.png" style="display: block; margin: auto;" /&gt;

---

# With different kernel


```r
kpcaout &lt;- embed(.data = wb, .method="kPCA",kernel='tanhdot',kpar=list(scale=1))
```

&lt;img src="04KPCA_files/figure-html/unnamed-chunk-11-1.png" style="display: block; margin: auto;" /&gt;

---


# Image example

- Read in png files of images of the letter 'A' rotated and rescaled.
--

- There are 124848 variables.
--

- Only 10898 of these variable have any variation across the images.
--

- Run PCA and kPCA only on these variables.
--

- Lesson: Don't try a complicated dimension reduction technique when a simple one is better.

---

# PCA

&lt;img src="04KPCA_files/figure-html/unnamed-chunk-12-1.png" style="display: block; margin: auto;" /&gt;

---

# Kernel PCA

&lt;img src="04KPCA_files/figure-html/unnamed-chunk-13-1.png" style="display: block; margin: auto;" /&gt;

---

# Conclusion

- Kernel PCA has the advantage of being a non-linear dimension reduction technique.
--

- Some disadvantages include:
--

  + Need to choose a kernel.
  + Need to choose tuning parameters for the kernel.
  + Eigendecomposition is slow for large `\(n\)`, although this can be mitigated by using a kernel that imposes sparsity.

  
---

class: center, inverse, middle

# Questions?
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="libs/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"slideNumberFormat": "%current%",
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
